/* LOGINCommand.cc */

#include	<string>
#include <iomanip.h>

#include	"md5hash.h" 
#include	"StringTokenizer.h"
#include	"ELog.h" 
#include	"cservice.h" 
#include	"responses.h" 
#include	"networkData.h"

const char LOGINCommand_cc_rcsId[] = "$Id: LOGINCommand.cc,v 1.11 2001/02/16 20:20:26 plexus Exp $" ;

namespace gnuworld
{

using namespace gnuworld;
 
bool LOGINCommand::Exec( iClient* theClient, const string& Message )
{
 
	StringTokenizer st( Message ) ;
	if( st.size() < 3 )
	{
		Usage(theClient);
		return true;
	}

 	/*
	 *  Check theClient isn't already logged in, if so, tell them they shouldn't be.
	 */
 
	sqlUser* tmpUser = bot->isAuthed(theClient, false);
	if (tmpUser) {
		bot->Notice(theClient, bot->getResponse(tmpUser, language::already_authed).c_str(),
			tmpUser->getUserName().c_str());
		return false;
	}

	/*
	 *  Find the user record, confirm authorisation and attach the record to this client. 
	 */
 
	sqlUser* theUser = bot->getUserRecord(st[1]);
	if (theUser) { 
		/*
		 *  Compare password with MD5 hash stored in user record.
		 */

		md5	hash; // MD5 hash algorithm object.
		md5Digest digest; // MD5Digest algorithm object.
		strstream output;
		string salt = theUser->getPassword().substr(0, 8);
		string md5Part = theUser->getPassword().substr(8);
		string guess = salt + st.assemble(2);

		// Build a MD5 hash based on our salt + the guessed password.
		hash.update( (unsigned char *)guess.c_str(), strlen( guess.c_str() ));
		hash.report( digest );

		// Convert the digest into an array of int's to output as hex for 
		// comparison with the passwords generated by PHP.
		int data[ MD5_DIGEST_LENGTH ];
		int ii;
		for( ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
		{
			data[ii] = digest[ii];
		}
		output << hex;
		output.fill('0');
		for( ii = 0; ii < MD5_DIGEST_LENGTH; ii++ ) {
			output << setw(2) << data[ii];
		}
		output << ends;

		if (output.str() != md5Part) // If the MD5 hash's don't match..
		{
			bot->Notice(theClient, 
				bot->getResponse(theUser,
					language::auth_failed,
					string("AUTHENTICATION FAILED as %s (Invalid Password).")).c_str(), 
				theUser->getUserName().c_str());
			return false;
		}

		/*
		 *  Check this user isn't already spoken for..
		 *  If someone HAS authenticated as this user, then deauth that other
		 *  person.
		 */

		iClient* authTestUser = theUser->isAuthed();
		if (authTestUser)
		{
			bot->Notice(authTestUser, 
				bot->getResponse(tmpUser,
					language::no_longer_auth,
					string("NOTICE: %s has now authenticated as %s, you are no longer authenticated.")).c_str(),
					theClient->getNickUserHost().c_str(), theUser->getUserName().c_str());
			networkData* tmpData = (networkData*)authTestUser->getCustomData(bot);
			tmpData->currentUser = NULL; // Remove the pointer from the iClient to the sqlUser.
		}
 
		theUser->setLastSeen(bot->currentTime());
		theUser->setFlag(sqlUser::F_LOGGEDIN);
		theUser->networkClient = theClient; // Who is authed as this user. 

		networkData* newData = (networkData*)theClient->getCustomData(bot);
		newData->currentUser = theUser; // Pointer back to the sqlUser from this iClient. 

		bot->Notice(theClient, bot->getResponse(theUser, language::auth_success).c_str(), 
			theUser->getUserName().c_str()); 

	} else
	{
		bot->Notice(theClient, 
			bot->getResponse(tmpUser,
				language::not_registered,
				string("Sorry, I don't know who %s is.")).c_str(), 
			st[1].c_str());
		return false;
	}

	return true; 
} 

} // namespace gnuworld.
