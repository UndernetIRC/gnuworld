/* LOGINCommand.cc */

#include	<string>
#include <iomanip.h>

#include	"md5hash.h" 
#include	"StringTokenizer.h"
#include	"ELog.h" 
#include	"cservice.h" 
#include	"responses.h" 
#include	"networkData.h"

const char LOGINCommand_cc_rcsId[] = "$Id: LOGINCommand.cc,v 1.14 2001/03/06 23:44:00 gte Exp $" ;

namespace gnuworld
{

using namespace gnuworld;
 
bool LOGINCommand::Exec( iClient* theClient, const string& Message )
{
 
StringTokenizer st( Message ) ;
if( st.size() < 3 )
	{
	Usage(theClient);
	return true;
	}

/*
 * Check theClient isn't already logged in, if so, tell
 * them they shouldn't be.
 */
 
sqlUser* tmpUser = bot->isAuthed(theClient, false);
if (tmpUser)
	{
	bot->Notice(theClient,
		bot->getResponse(tmpUser, language::already_authed).c_str(),
		tmpUser->getUserName().c_str());
	return false;
	}

/*
 * Find the user record, confirm authorisation and attach the record
 * to this client. 
 */

if(st[1][0] == '#')
{
	bot->Notice(theClient, "Sorry, I don't know who %s is.", st[1].c_str());
	return false;
}

// TODO: Force a refresh of the user's info from the db 
sqlUser* theUser = bot->getUserRecord(st[1]);
if( !theUser )
	{
	bot->Notice(theClient, 
		bot->getResponse(tmpUser,
			language::not_registered,
			string("Sorry, I don't know who %s is.")).c_str(), 
		st[1].c_str());
	return false;
	}

/*
 *  Compare password with MD5 hash stored in user record.
 */

// MD5 hash algorithm object.
md5	hash;

// MD5Digest algorithm object.
md5Digest digest;

string salt = theUser->getPassword().substr(0, 8);
string md5Part = theUser->getPassword().substr(8);
string guess = salt + st.assemble(2);

// Build a MD5 hash based on our salt + the guessed password.
hash.update( (const unsigned char *)guess.c_str(), guess.size() );
hash.report( digest );

// Convert the digest into an array of int's to output as hex for 
// comparison with the passwords generated by PHP.
int data[ MD5_DIGEST_LENGTH ] = { 0 } ;

for( size_t ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
	{
	data[ii] = digest[ii];
	}

strstream output;
output << hex;
output.fill('0');

for( size_t ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
	{
	output << setw(2) << data[ii];
	}
output << ends;

if(md5Part != output.str() ) // If the MD5 hash's don't match..
	{
	bot->Notice(theClient, 
		bot->getResponse(theUser,
			language::auth_failed,
			string("AUTHENTICATION FAILED as %s (Invalid Password).")).c_str(), 
		theUser->getUserName().c_str());

	delete[] output.str() ;
	return false;
	}

delete[] output.str() ;

/*
 *  Check this user isn't already spoken for..
 *  If someone HAS authenticated as this user, then deauth that other
 *  person.
 */

iClient* authTestUser = theUser->isAuthed();
if (authTestUser)
	{
	bot->Notice(authTestUser, 
		bot->getResponse(tmpUser,
			language::no_longer_auth,
			string("NOTICE: %s has now authenticated as %s, you are no longer authenticated.")).c_str(),
			theClient->getNickUserHost().c_str(),
			theUser->getUserName().c_str());

	networkData* tmpData =
		static_cast< networkData* >( authTestUser->getCustomData(bot) ) ;
	if( NULL == tmpData )
		{
		bot->Notice( authTestUser,
			"Internal error." ) ;
		elog	<< "LOGINCommand> tmpData is NULL for: "
			<< *authTestUser
			<< endl ;
		return false ;
		}

	// Remove the pointer from the iClient to the sqlUser.
	tmpData->currentUser = NULL;
	}
 
theUser->setLastSeen(bot->currentTime());
theUser->setFlag(sqlUser::F_LOGGEDIN);
theUser->networkClient = theClient; // Who is authed as this user. 

networkData* newData =
	static_cast< networkData* >( theClient->getCustomData(bot) ) ;
if( NULL == newData )
	{
	bot->Notice( authTestUser,
		"Internal error." ) ;
	elog	<< "LOGINCommand> newData is NULL for: "
		<< *authTestUser
		<< endl ;
	return false ;
	}

// Pointer back to the sqlUser from this iClient. 
newData->currentUser = theUser;

bot->Notice(theClient,
	bot->getResponse(theUser, language::auth_success).c_str(), 
	theUser->getUserName().c_str()); 

/*
 * The fun part! For all channels this user has access on, and has
 * AUTOP set, and isn't already opp'd on - do the deed. 
 */ 


return true; 
} 

} // namespace gnuworld.
