/*
 * LOGINCommand.cc
 *
 * Authenticates you with the bot
 */

#include	<string>
#include	<cstdlib>
#include	"Network.h"
#include	"ccontrol.h"
#include	"CControlCommands.h"
#include	"StringTokenizer.h"
#include	"md5hash.h" 
#include        "ccUser.h"
#include	"ip.h"

const char LOGINCommand_cc_rcsId[] = "$Id: LOGINCommand.cc,v 1.22 2002/02/01 11:14:04 mrbean_ Exp $";

namespace gnuworld
{

using std::string ;

namespace uworld
{

bool LOGINCommand::Exec( iClient* theClient, const string& Message)
{
StringTokenizer st( Message ) ;

if(!dbConnected)
        {
        bot->Notice(theClient,"Sorry, but the db connection is down now, please try again alittle later");
        return false;
        }

if( st.size() < 3 )
	{
	Usage(theClient);
	return true;
	}
//Try fetching the user authenticate entry
ccUser* theUser = bot->IsAuth(theClient);
if (theUser) 
	{
	//Dont let him authenticate under a new name (for now)
	bot->Notice(theClient, "You  are already authenticated! ");
	return false;
	}

	/*
	 *  Find the user record, confirm authorisation and attach the record to this client. 
	 */
 
theUser = bot->GetOper(st[1]);
if (!theUser) 
	{
	bot->MsgChanLog("[FAILED LOGIN] %s - Bad Username\n",theClient->getNickUserHost().c_str());
	if(theClient->isOper())
		bot->Notice(theClient, "FALSE LOGIN, DENIED");
	bot->addLogin(theClient);
	return false;
	}
else
	{ 
	//Check if the user need to be operd to login
	if((!theClient->isOper()) && (theUser->getNeedOp()))

		{
		bot->MsgChanLog("[FAILED LOGIN] %s - Not Operd\n",theClient->getNickUserHost().c_str());
		bot->addLogin(theClient);
		return false;
		}
	//Check if the users mask is in his access list
		
	if((!bot->UserGotMask(theUser,theClient->getNickUserHost()))
	    &&(!bot->UserGotMask(theUser,xIP(theClient->getIP()).GetNumericIP())))	
		{
		bot->MsgChanLog("[FAILED LOGIN] %s - No HostMask\n",theClient->getNickUserHost().c_str());
	
		bot->Notice(theClient, "FALSE LOGIN, DENIED");
		bot->addLogin(theClient);
		return false;
		}

	md5	hash; // MD5 hash algorithm object.
	md5Digest digest; // MD5Digest algorithm object.
	strstream output;
	string salt = theUser->getPassword().substr(0, 8);
	string md5Part = theUser->getPassword().substr(8);
	string guess = salt + st.assemble(2);

	// Build a MD5 hash based on our salt + the guessed password.
	hash.update( (unsigned char *)guess.c_str(), strlen( guess.c_str() ));
	hash.report( digest );

	// Convert the digest into an array of int's to output as hex for 
	// comparison with the passwords generated by PHP.
	int data[ MD5_DIGEST_LENGTH ];
	int ii;
	for( ii = 0; ii < MD5_DIGEST_LENGTH; ii++ )
		{
		data[ii] = digest[ii];
		}
	output << hex;
	output.fill('0');
	for( ii = 0; ii < MD5_DIGEST_LENGTH; ii++ ) {
		output << setw(2) << data[ii];
		}
	output << ends;

	if (md5Part != output.str()) // If the MD5 hash's don't match..
		{
		bot->MsgChanLog("[FAILED LOGIN] %s - Bad Password\n",theClient->getNickUserHost().c_str());
		bot->Notice(theClient, "FALSE LOGIN, DENIED");
		bot->addLogin(theClient);
		return false;
		}
	//Ok the password match , prepare the ccUser data
	if(theUser->getClient()) //there is already a user authenticated under that nick
		{
		const iClient *tClient = theUser->getClient();
		bot->Notice(tClient,"You have just been deauthenticated");
		bot->MsgChanLog("Login conflict for user %s from %s and %s\n"
				,st[1].c_str(),theClient->getNickName().c_str()
				,tClient->getNickName().c_str());
		bot->deAuthUser(theUser);
		}
	theUser->setUserName(st[1]);
	theUser->setNumeric(theClient->getCharYYXXX());
	//Try creating an authentication entry for the user
	if(bot->AuthUser(theUser,theClient))
		if(!(bot->isSuspended(theUser)))
			bot->Notice(theClient, "Authentication successful! ",theUser->getUserName().c_str()); 
		else 
			bot->Notice(theClient, "Authentication successful,However you are suspended ",theUser->getUserName().c_str()); 
	else
	        bot->Notice(theClient, "Error in authentication ",theUser->getUserName().c_str()); 
        bot->MsgChanLog("(%s) - %s : AUTHENTICATED\n",theUser->getUserName().c_str()
                        ,theClient->getNickUserHost().c_str());
	} 

return true; 
} 

}
} // namespace gnuworld

